<script>
// 安全的Matrix背景动画 - 使用JavaScript模式集成
document.addEventListener('DOMContentLoaded', function() {
    // 延迟加载确保页面完全渲染
    setTimeout(function() {
        // 创建Canvas背景容器
        const canvasContainer = document.createElement('div');
        canvasContainer.id = 'matrix-background';
        canvasContainer.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1000;
            pointer-events: none;
            opacity: 0.15;
        `;
        
        // 创建Canvas元素
        const canvas = document.createElement('canvas');
        canvas.id = 'matrix-canvas';
        canvas.style.cssText = `
            display: block;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0d1117 0%, #161b22 50%, #0d1117 100%);
        `;
        
        canvasContainer.appendChild(canvas);
        
        // Matrix变换动画类
        class MatrixTransformAnimation {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.setupCanvas();
                this.init();
                this.animate();
                
                window.addEventListener('resize', () => this.setupCanvas());
            }
            
            setupCanvas() {
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = window.innerWidth * dpr;
                this.canvas.height = window.innerHeight * dpr;
                this.canvas.style.width = window.innerWidth + 'px';
                this.canvas.style.height = window.innerHeight + 'px';
                this.ctx.scale(dpr, dpr);
                
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                this.centerX = this.width / 2 + this.width * 0.2;
                this.centerY = this.height / 2 + this.height * 0.12;
                this.scale = Math.min(this.width, this.height) / 22;
                
                if (this.gridLines) {
                    this.gridLines = this.createGridLines();
                }
            }
            
            init() {
                this.time = 0;
                this.animationSpeed = 0.01;
                
                this.transformations = [
                    { name: "Identity", matrix: [1, 0, 0, 1], duration: 2 },
                    { name: "Rotation", matrix: [Math.cos(Math.PI/4), -Math.sin(Math.PI/4), Math.sin(Math.PI/4), Math.cos(Math.PI/4)], duration: 3 },
                    { name: "Scale", matrix: [1.5, 0, 0, 0.7], duration: 2 },
                    { name: "Shear", matrix: [1, 0.5, 0, 1], duration: 2 },
                    { name: "Reflection", matrix: [-1, 0, 0, 1], duration: 2 },
                    { name: "Complex", matrix: [0.8, 0.6, -0.6, 0.8], duration: 3 }
                ];
                
                this.totalDuration = this.transformations.reduce((sum, t) => sum + t.duration, 0);
                this.gridLines = this.createGridLines();
            }
            
            createGridLines() {
                const lines = [];
                const rangeX = Math.ceil(this.width / this.scale) + 2;
                const rangeY = Math.ceil(this.height / this.scale) + 2;
                
                for (let x = -rangeX; x <= rangeX; x++) {
                    lines.push({
                        start: { x: x, y: -rangeY },
                        end: { x: x, y: rangeY },
                        isAxis: x === 0
                    });
                }
                
                for (let y = -rangeY; y <= rangeY; y++) {
                    lines.push({
                        start: { x: -rangeX, y: y },
                        end: { x: rangeX, y: y },
                        isAxis: y === 0
                    });
                }
                
                return lines;
            }
            
            getCurrentTransformation() {
                const cycle = (this.time * this.animationSpeed) % this.totalDuration;
                let elapsed = 0;
                
                for (let i = 0; i < this.transformations.length; i++) {
                    const transform = this.transformations[i];
                    if (cycle <= elapsed + transform.duration) {
                        const progress = (cycle - elapsed) / transform.duration;
                        const nextIndex = (i + 1) % this.transformations.length;
                        const current = transform.matrix;
                        const next = this.transformations[nextIndex].matrix;
                        const t = 0.5 * (1 - Math.cos(Math.PI * progress));
                        
                        return {
                            matrix: [
                                current[0] + (next[0] - current[0]) * t,
                                current[1] + (next[1] - current[1]) * t,
                                current[2] + (next[2] - current[2]) * t,
                                current[3] + (next[3] - current[3]) * t
                            ],
                            name: transform.name
                        };
                    }
                    elapsed += transform.duration;
                }
                
                return { matrix: [1, 0, 0, 1], name: "Identity" };
            }
            
            transformPoint(x, y, matrix) {
                return {
                    x: matrix[0] * x + matrix[1] * y,
                    y: matrix[2] * x + matrix[3] * y
                };
            }
            
            toScreenCoords(x, y) {
                return {
                    x: this.centerX + x * this.scale,
                    y: this.centerY - y * this.scale
                };
            }
            
            drawGrid(matrix) {
                this.ctx.save();
                
                this.gridLines.forEach(line => {
                    const transformedStart = this.transformPoint(line.start.x, line.start.y, matrix);
                    const transformedEnd = this.transformPoint(line.end.x, line.end.y, matrix);
                    
                    const screenStart = this.toScreenCoords(transformedStart.x, transformedStart.y);
                    const screenEnd = this.toScreenCoords(transformedEnd.x, transformedEnd.y);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenStart.x, screenStart.y);
                    this.ctx.lineTo(screenEnd.x, screenEnd.y);
                    
                    if (line.isAxis) {
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.lineWidth = 1.5;
                    } else {
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                        this.ctx.lineWidth = 0.5;
                    }
                    
                    this.ctx.stroke();
                });
                
                this.ctx.restore();
            }
            
            animate() {
                this.time++;
                
                this.ctx.fillStyle = '#0d1117';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                const current = this.getCurrentTransformation();
                this.drawGrid(current.matrix);
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // 启动Matrix动画
        new MatrixTransformAnimation(canvas);
        
        // 插入到body开头，避免影响现有内容
        document.body.insertBefore(canvasContainer, document.body.firstChild);
    }, 1000); // 延迟1秒，模仿计数器的安全做法
});
</script>